

;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-38F3-7EE4-0C			    |
; |			    University of Illinois			    |
; +-------------------------------------------------------------------------+
;
; Input	SHA256 : 063A8D9A5E0C2BDF2CE49694E2CB2784AE7026DB667F8428557F1D594D04E37A
; Input	MD5    : 0A9A5BEAD2F507B7308C05DB9A864C47
; Input	CRC32  : A9EA1A36

; File Name   :	/home/sdasgup3/Github/binary-decompilation/test/variable_recovery/test_0/Output/test_0.clang.o
; Format      :	ELF64 for x86-64 (Relocatable)
;
; Source File :	'test_0.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	dword public 'CODE' use64
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl swap(int	*a, int	*b)
		public swap
swap		proc near		; CODE XREF: main+24p

b		= qword	ptr -10h
a		= qword	ptr -8

		push	rbp
		mov	rbp, rsp
		mov	[rbp+a], rdi
		mov	[rbp+b], rsi
		mov	rax, [rbp+a]
		cmp	rax, [rbp+b]
		jz	short loc_54
		mov	rax, [rbp+a]
		mov	edx, [rax]
		mov	rax, [rbp+b]
		mov	eax, [rax]
		xor	edx, eax
		mov	rax, [rbp+a]
		mov	[rax], edx
		mov	rax, [rbp+a]
		mov	edx, [rax]
		mov	rax, [rbp+b]
		mov	eax, [rax]
		xor	edx, eax
		mov	rax, [rbp+b]
		mov	[rax], edx
		mov	rax, [rbp+a]
		mov	edx, [rax]

loc_44:					; DATA XREF: .eh_frame:00000000000000F4o
		mov	rax, [rbp+b]
		mov	eax, [rax]
		xor	edx, eax
		mov	rax, [rbp+a]
		mov	[rax], edx
		jmp	short loc_55
; ---------------------------------------------------------------------------

loc_54:					; CODE XREF: swap+14j
		nop

loc_55:					; CODE XREF: swap+52j
		pop	rbp
		retn
swap		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near		; DATA XREF: .eh_frame:00000000000000D4o

two		= dword	ptr -8
one		= dword	ptr -4

		push	rbp
		mov	rbp, rsp
		sub	rsp, 10h
		mov	[rbp+one], 1
		mov	[rbp+two], 2
		lea	rdx, [rbp+two]
		lea	rax, [rbp+one]
		mov	rsi, rdx	; b
		mov	rdi, rax	; a
		call	swap
		mov	edx, [rbp+two]
		mov	eax, [rbp+one]
		mov	esi, eax
		mov	edi, offset format ; "%d %d\n"
		mov	eax, 0
		call	printf
		mov	eax, 0
		leave

locret_9D:				; DATA XREF: .eh_frame:00000000000000D0o
					; .eh_frame:00000000000000F0o
		retn
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use64
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use64
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rodata		segment	byte public 'CONST' use64
		assume cs:_rodata
		;org 0A5h
; char format[]
format		db '%d %d',0Ah,0        ; DATA XREF: main+31o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_eh_frame	segment	para public 'CONST' use64
		assume cs:_eh_frame
		;org 0B0h
		db  14h
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    1
		db  7Ah	; z
		db  52h	; R
		db    0
		db    1
		db  78h	; x
		db  10h
		db    1
		db  1Bh
		db  0Ch
		db    7
		db    8
		db  90h	; ê
		db    1
		db    0
		db    0
		db  1Ch
		db    0
		db    0
		db    0
		db  1Ch
		db    0
		db    0
		db    0
		dd offset locret_9D+0FFFFFE93h
		dd offset main
		db    0
		db  41h	; A
		db  0Eh
		db  10h
		db  86h	; Ü
		db    2
		db  43h	; C
		db  0Dh
		db    6
		db    2
		db  52h	; R
		db  0Ch
		db    7
		db    8
		db    0
		db    0
		db  1Ch
		db    0
		db    0
		db    0
		db  3Ch	; <
		db    0
		db    0
		db    0
		dd offset locret_9D+0FFFFFECAh
		dd offset loc_44+3
		db    0
		db  41h	; A
		db  0Eh
		db  10h
		db  86h	; Ü
		db    2
		db  43h	; C
		db  0Dh
		db    6
		db    2
		db  42h	; B
		db  0Ch
		db    7
		db    8
		db    0
		db    0
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: main+3Bp


		end
